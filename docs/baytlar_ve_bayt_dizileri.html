
 <!DOCTYPE html>
 <html lang="tr">


<html lang="tr" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content="Python 3.x'te baytlar adlı veri tipi" name="description" />
<meta content="python, bayt, baytlar, bytes, karakter, karakter dizisi, encode" name="keywords" />

    <title>Baytlar (Bytes) ve Bayt Dizileri (Bytearrays) &#8212; Yazbel Python Belgeleri</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=36871c9a" />
    <link rel="stylesheet" type="text/css" href="_static/pyramid.css?v=bd158598" />
    <script src="_static/documentation_options.js?v=4e2d7ee8"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/translations.js?v=5dbee647"></script>
    <link rel="canonical" href="https://python-istihza.yazbel.com/baytlar_ve_bayt_dizileri.html" />
    <link rel="icon" href="_static/favicon.ico"/>
    <link rel="index" title="Dizin" href="genindex.html" />
    <link rel="search" title="Ara" href="search.html" />
    <link rel="next" title="Sözlükler" href="sozlukler.html" />
    <link rel="prev" title="Karakter Kodlama (Character Encoding)" href="karakter_kodlama.html" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>
<div class='header'><a href='https://yazbel.com'><img src="_static/logo.png"></a></div>

<ul class='navbar'>
    <li><a href="http://forum.yazbel.com">forum</a></li>
    <li><a href="https://github.com/yazbel/python-istihza">github</a></li>
    <li><a href="YazbelPythonProgramlamaDiliBelgeleri.pdf">pdf</a></li>
    <!-- <li><a href="YazbelPythonProgramlamaDiliBelgeleri.epub">epub</a></li> the file format is wrong so we are disabling it for now-->
    <li><a href="YazbelPythonProgramlamaDiliBelgeleri.html">html</a></li>
</ul>


    <div class="related" role="navigation" aria-label="Related">
      <h3>Gezinti</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Genel Dizin"
             accesskey="I">dizin</a></li>
        <li class="right" >
          <a href="sozlukler.html" title="Sözlükler"
             accesskey="N">sonraki</a> |</li>
        <li class="right" >
          <a href="karakter_kodlama.html" title="Karakter Kodlama (Character Encoding)"
             accesskey="P">önceki</a> |</li>
<li class="nav-item nav-item-0"><a href=".">&#x2302;</a></li>

        <li class="nav-item nav-item-this"><a href="">Baytlar (Bytes) ve Bayt Dizileri (Bytearrays)</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            

  <section id="baytlar-bytes-ve-bayt-dizileri-bytearrays">
<h1>Baytlar (Bytes) ve Bayt Dizileri (Bytearrays)<a class="headerlink" href="#baytlar-bytes-ve-bayt-dizileri-bytearrays" title="Link to this heading">¶</a></h1>
<p>Bu bölüme gelinceye kadar veri tipi olarak karakter dizilerinden, listelerden ve
dosyalardan söz etmiştik. Bu bölümde ise Python programlama dilindeki iki veri
tipinden daha söz edeceğiz. Birbirleriyle doğrudan bağlantılı oldukları için
bu bölümde birlikte ele alacağımız bu veri tiplerinin adı ‘baytlar’(<em>bytes</em>) ve
‘bayt dizileri’ (<em>bytearrays</em>).</p>
<p>Bu bölümde yalnızca ‘baytlar’ ve ‘bayt dizileri’ adlı veri tiplerinden söz
etmeyeceğiz. Bu iki yeni veri tipini bilgi dağarcığımıza eklemenin yanısıra,
önceki bölümlerde öğrendiğimiz konuları zihnimizde pekiştirmeye ve
sağlamlaştırmaya da devam edeceğiz.</p>
<section id="giris">
<h2>Giriş<a class="headerlink" href="#giris" title="Link to this heading">¶</a></h2>
<p>Bilgisayar teknolojisi ve bilimi açısından ‘karakter’ tamamen soyut bir
kavramdır. Son birkaç bölümdür üstüne basa basa tekrar ettiğimiz gibi, karakter
dediğimiz şey, bilgisayarların anlayabildiği tek kavram olan sayılara biz
insanların atadığı birtakım işaretlerden ibarettir. Dolayısıyla bilgisayarlar
açısından karakterler değil, ikili sayma düzenindeki birtakım sayılar, yani
bitler ve baytlar vardır.</p>
<p>Teknik olarak 1 bit, ikili sayma sistemindeki her bir basamağa verilen isimdir.
Zaten ‘bit’ kelimesinin de İngilizcede ‘ikili basamak’ anlamına gelen ‘<em>binary
digit</em> ifadesinin kısaltması olduğunu geçen bölümde öğrenmiştiniz.</p>
<p>Örneğin ikili sayma sistemindeki <cite>0</cite>, bir bitlik bir sayı iken, <cite>100</cite> üç bitlik
bir sayıdır. Bu bit’lerin <cite>8</cite> tanesi bir araya gelince ‘bayt’ denen birimi
oluşturur. Yani bayt, 8 adet bit’ten oluşan bir birimdir. Nasıl bir düzinede 10,
bir destede de 12 öğe olmasını biz insanlar tercih etmiş ve belirlemişsek, bir
bayt’ta da 8 bit olmasını yine biz insanlar tercih etmiş ve belirlemişizdir.</p>
<p>Önceki derslerimizde de öğrendiğimiz gibi, 8 adet bit, yani 1 bayt,
Genişletilmiş ASCII sisteminde bir adet karakteri temsil etmek için
kullanılabilecek en büyük birim olarak tasarlanmıştır. Yani Genişletilmiş ASCII
tablolarının en sonundaki 255 numaralı karakteri temsil edebilmek için 8 adet
bit, yani toplam 1 bayt kullanmamız gerekir. Standart ASCII sistemi ise 7 bitlik
bir sistem olduğu için, bir adet karakteri temsil etmek için kullanılabilecek en
büyük birimin 7 bit olduğunu biliyorsunuz. Dolayısıyla ASCII sistemindeki son
karaktere karşılık gelen 127. sayıyı temsil edebilmek için toplam 7 bit
yeterlidir.</p>
<p>Farklı bir sistem olan UTF-8 ise birden fazla bayt kullanarak çok sayıda
karakteri temsil etmeye imkan tanır. UTF-8 ile, duruma göre 1, 2, 3 veya 4 bayt
kullanarak, UNICODE sistemi içinde tanımlanmış bütün karakterleri temsil
edebilirsiniz. UTF-8, değişken boyutlu bir kodlama sistemi olması sayesinde, bir
karakteri temsil edebilmek için kaç bayt gerekiyorsa, o karakteri temsil etmek
için o kadar bayt kullanır. Ama mesela UTF-32 adlı kod çözücü hangi karakter
olursa olsun hepsini 4 bayt (32 bit) ile temsil eder. Bu durumda aslında tek
baytla temsil edilebilecek ‘a’, ‘b’, ‘c’ gibi karakterler de boşu boşuna 4 bayt
yer kaplamış olur. Zaten UTF-8’in bu kadar yaygın ve gözde olmasının nedeni de
hem çok sayıda karakteri kodlayabilmesi, hem de bu işi yaparken tasarruflu
olmayı başarabilmesidir.</p>
<p>Python programlama dilinde karakter dizileri UNICODE kod konumları şeklinde
temsil edilir. Dolayısıyla <cite>str</cite> adı verilen veri tipi esasında karakter
dizilerini birtakım UNICODE kod konumları şeklinde gösteren soyut bir yapıdır.
Yani biz Python’da karakter dizileri üzerinde işlem yaparken aslında baytlarla
değil, UNICODE kod konumları ile muhatap oluyoruz. Ancak UNICODE kod konumları
da tamamen soyut kavramlardır. Bunları bilgisayarın belleğinde bu şekilde temsil
edemezsiniz ya da bu kod konumlarını herhangi bir ağ üzerinden başka
bilgisayarlara iletemezsiniz. Bu kod konumlarını anlamlı bir şekilde
kullanabilmek için öncelikle bunları bilgisayarların anlayabileceği bir biçim
olan baytlara çevirmeniz gerekir. Çünkü dediğimiz gibi bilgisayarlar yalnızca
bitler ve baytlardan anlar. İşte kod çözücülerin görevi de zaten bu kod
konumlarını baytlara çevirmektir.</p>
<p>Esasında programcılık maceranız boyunca genellikle metin ihtiyaçlarınızı UNICODE
kod konumları üzerinden halledeceksiniz. Python sistemdeki öntanımlı kod
çözücüyü kullanarak bu kod konumlarını alttan alta bayta çevirip bellekte
saklayacaktır. Ama eğer yazdığınız programlarda herhangi bir şekilde doğrudan
baytlarla muhatap olmanız gerekirse <cite>str</cite> veri tipini değil, <cite>bytes</cite> adlı başka
bir veri tipini kullanacaksınız. Örneğin ikili (<em>binary</em>) dosyalar üzerinde
çeşitli çalışmalar yapacaksanız ve bu ikili dosyalara birtakım veriler
girecekseniz, gireceğiniz bu veriler <cite>bytes</cite> tipinde olacaktır.</p>
<p>Bütün bu sebeplerden ötürü, <cite>str</cite> ve <cite>bytes</cite> veri tipleri arasındaki farkı
anlamak, yazdığınız programların kararlılığı ve sağlamlığı açısından büyük önem
taşır. O anda elinizde olan verinin hangi tipte olduğunu bilmezseniz, bu
verinin, programınızın çalışması esnasında size ne tür tuzaklar kurabileceğini
de kestiremezsiniz. Örneğin bütün karakterlerin 1 bayt olduğunu ve bunların da
yalnızca 0 ile 127 arası sayılarla temsil edilebileceğini zanneden
yazılımcıların tasarladığı programlara Türkçe karakterler girdiğinizde nasıl bu
programlar patır patır dökülüyorsa, eğer siz de baytlar ve karakterler
arasındaki farkı anlamazsanız sizin yazdığınız programlar da hiç beklemediğiniz
bir anda tökezleyebilir.</p>
<p>Örneğin yazdığınız bir programın bir aşamasında programa yalnızca tek
karakterlik verilerin girilmesi temeli üzerinden bir işlem yaptığınızı düşünün.
Yani programınız içinde yapacağınız bir işlem, birden fazla karakter girişinin
engellenmesini gerektiriyor olsun.</p>
<p>Bunun için şöyle bir şey yazmış olun:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lütfen yalnızca tek bir karakter giriniz!&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Teşekkürler!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Ben burada temsili olarak <cite>a</cite> adlı bir değişken oluşturdum ve örnek olması
açısından da bunun değerini ‘k’ olarak belirledim. Bu değerlerle programımız
düzgün bir şekilde çalışır. Çünkü <cite>a</cite> değişkeninin değeri tek bir karakter olan
‘k’ harfi. Ama eğer <cite>a</cite> değişkeninin değeri mesela ‘kz’ gibi bir şey olsaydı
programımız ‘Lütfen yalnızca tek bir karakter giriniz!’ uyarısı verecekti…</p>
<p>Şimdi bu <cite>a</cite> değişkeninin sizin tarafınızdan belirlenmediğini, bu değerin başka
bir kaynaktan geldiğini düşünün. Eğer size bu değeri gönderen kaynak, bu değeri
UNICODE kod konumu olarak gönderiyorsa programınız düzgün çalışır. Ama peki ya
gelen bu veri bayt olarak geliyorsa ne olacak?</p>
<p>Yukarıda verdiğimiz örneğin neden önemli olduğunu, daha doğrusu bu örnekle ne
demek istediğimiz ve nereye varmaya çalıştığımızı anlamamış olabilirsiniz. Ama
endişe etmenize hiç gerek yok. Zira bu bölümde yukarıda sorduğumuz sorunun
cevabını derinlemesine ele alacağız. Bu bölümün sonuna vardığımızda neler olup
bittiğini ve baytların neden bu kadar önemli olduğunu gayet iyi anlıyor
olacaksınız.</p>
</section>
<section id="eskisi-ve-yenisi">
<h2>Eskisi ve Yenisi<a class="headerlink" href="#eskisi-ve-yenisi" title="Link to this heading">¶</a></h2>
<p>Gelin isterseniz tam olarak ne ile karşı karşıya olduğumuzu daha iyi
anlayabilmek için Python3 öncesi durumun nasıl olduğuna bakalım. Eğer geçmişte
Python programlama dilinin karakter dizileri ve baytları nasıl ele aldığını
bilirsek bugünkü durumu ve dolayısıyla genel olarak karakter dizisi ve bayt
kavramını çok daha net bir şekilde kavrayabiliriz.</p>
<p>Python’ın 2.x sürümlerinde, bir karakter dizisi tanımladığınızda Python bu
karakter dizisini bir bayt dizisi olarak temsil ediyordu. Örneğin:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kardiz</span> <span class="o">=</span> <span class="s2">&quot;e&quot;</span>
</pre></div>
</div>
<p>Burada <cite>kardiz</cite> adlı değişkenin değeri, bir baytlık bir karakter dizisidir. Bunu
<code class="docutils literal notranslate"><span class="pre">len()</span></code> fonksiyonu ile teyit edelim:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">kardiz</span><span class="p">)</span>

<span class="go">1</span>
</pre></div>
</div>
<p>Bir de şuna bakalım:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kardiz</span> <span class="o">=</span> <span class="s2">&quot;ş&quot;</span>
</pre></div>
</div>
<p>Burada ise <cite>kardiz</cite> adlı değişkenin değerinin kaç baytlık bir karakter dizisi
olduğu, yani bir bakıma <code class="docutils literal notranslate"><span class="pre">len()</span></code> fonksiyonunun ne çıktı vereceği işletim
sisteminden işletim sistemine farklılık gösterir. Eğer kullandığınız işletim
sistemi Windows ise muhtemelen <code class="docutils literal notranslate"><span class="pre">len(kardiz)</span></code> komutu <cite>1</cite> çıktısı verecektir.
Ama eğer bu komutu GNU/Linux dağıtımlarından birinde veriyorsanız alacağınız
çıktı büyük ihtimalle <cite>2</cite> olacaktır.</p>
<p>Dediğimiz gibi, Python2’de <cite>str</cite> veri tipi bize bir dizi bayt verir. Dolayısıyla
bu veri tipinin içinde tuttuğu karakter dizisinin kaç bayt ile gösterileceği,
sistemdeki öntanımlı kod çözücünün hangisi olduğuna bağlıdır. Kullandığınız
işletim sisteminde öntanımlı kod çözücünün hangisi olduğunu şu komutla
bulabilirsiniz:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">locale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">locale</span><span class="o">.</span><span class="n">getpreferredencoding</span><span class="p">()</span>
</pre></div>
</div>
<p>Eğer Windows kullanıyorsanız buradan alacağınız çıktı muhtemelen cp1254
olacaktır. cp1254, Microsoft’un Türkçe için özel olarak kullandığı bir kod
sayfası olduğu için, 128 ile 256 sayıları arasında Türkçe karakterleri içerir. O
yüzden bu kodlama sisteminde Türkçe karakterler 1 bayt ile gösterilebilir. Bu
kod sayfasının içeriğinde hangi karakterlerin hangi sayılara karşılık geldiğini
görmek için <a class="reference external" href="https://en.wikipedia.org/wiki/Windows-1254">en.wikipedia.org/wiki/Windows-1254</a> adresindeki tabloyu
inceleyebilirsiniz.</p>
<p>Ama eğer yukarıdaki komutların çıktısı UTF-8 veya başka bir kod çözücü ise,
Türkçe karakterler 1 bayt ile gösterilemeyeceği için <code class="docutils literal notranslate"><span class="pre">len(kardiz)</span></code> komutu <cite>1</cite>
değil, <cite>2</cite> çıktısı verecektir.</p>
<p>Bir de şuna bakalım:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;€&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Bu komutu hangi işletim sisteminde verdiğinize bağlı olarak yukarıdaki komuttan
alacağınız çıktı farklı olacaktır. <cite>str</cite> tipi Python2’de karakter dizilerini
bayt olarak temsil eder. Bu temsilin de hangi kurallara göre yapılacağı
kullanılan kod çözücüye bağlıdır. Eğer karakter dizileri baytlara çevrilirken
cp1254 adlı kod çözücü kullanılırsa, bu kod çözücü ‘€’ simgesini tek bayt
ile gösterilebildiği için yukarıdaki komut <cite>1</cite> çıktısı verir. Ama UTF-8 adlı kod
çözücü ‘€’ simgesini <cite>3</cite> baytla gösterebildiği için yukarıdaki komutun çıktısı
da buna paralel olarak <cite>3</cite> olacaktır.</p>
<p><cite>str</cite> veri tipi ile gösterilen bu karakter dizilerinin içindeki baytlara ulaşmak
için şu yöntemi kullanabilirsiniz:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;ş&quot;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="go">&#39;\xc5&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;ş&quot;</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="go">&#39;\x9f&#39;</span>
</pre></div>
</div>
<p>Gördüğünüz gibi, <cite>str</cite> veri tipi gerçekten de bize bir dizi bayt veriyor. Eğer
karakter dizilerini baytlarına göre değil de sahip oldukları karakter sayısına
göre saymak isterseniz bunları UNICODE olarak tanımlanız gerekiyor:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="sa">u</span><span class="s1">&#39;ş&#39;</span><span class="p">)</span>

<span class="go">1</span>
</pre></div>
</div>
<p>Python3 ile birlikte yukarıda bahsettiğimiz durumda bazı değişiklikler oldu.
Artık <cite>str</cite> veri tipi UNICODE kod konumlarını döndürüyor. Dolayısıyla artık her
karakter dizisi, sahip oldukları karakter sayısına göre sayılabiliyor:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;ş&quot;</span><span class="p">)</span>

<span class="go">1</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;€&quot;</span><span class="p">)</span>

<span class="go">1</span>
</pre></div>
</div>
<p>İşte eğer Python2’deki <cite>str</cite> veri tipini elde etmek istiyorsanız, Python3’te
<cite>bytes</cite> adlı yeni veri tipini kullanmanız gerekiyor.</p>
</section>
<section id="bayt-tanimlamak">
<h2>Bayt Tanımlamak<a class="headerlink" href="#bayt-tanimlamak" title="Link to this heading">¶</a></h2>
<p>Bildiğiniz gibi Python programlama dilinde her veri tipinin kendine özgü bir
tanımlanma biçimi var. Örneğin bir liste tanımlamak için şöyle bir şey
yazıyoruz:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">liste</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>Böylece boş bir liste tanımlamış olduk. Aynı şekilde karakter dizilerini de
şöyle tanımlıyorduk:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kardiz</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
</pre></div>
</div>
<p>Bu şekilde de boş bir karakter dizisi tanımlamış olduk. İşte boş bir bayt
tanımlamak için de şu yapıyı kullanıyoruz:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bayt</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span>
</pre></div>
</div>
<p>Gelin tanımladığımız bu veri tipinin bayt olduğunu teyit edelim:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">bayt</span><span class="p">)</span>

<span class="go">&lt;class &#39;bytes&#39;</span>
</pre></div>
</div>
<p>Gördüğünüz gibi, gerçekten de bayt tipinde bir veri tanımlamışız. Nasıl karakter
dizileri ‘str’, listeler ‘list’ ifadesiyle gösteriliyorsa, baytlar da ‘bytes’
ifadesi ile gösterilir.</p>
<p>Peki bu şekilde bir bayt veri tipi tanımlamak ne işimize yarar?</p>
<p>Hatırlarsanız bayt veri tipini ikili (<em>binary</em>) dosyaları anlatırken de
görmüştük. Orada da söylediğimiz gibi, ikili dosyaları okuduğunuzda elde
edeceğiniz şey karakter dizisi değil bayttır. Aynı şekilde, ikili dosyalara da
ancak baytları yazabilirsiniz. Dolayısıyla eğer ikili dosyalarla birtakım
işlemler yapacaksanız bu bayt veri tipini yoğun olarak kullanacağınızdan hiç
şüpheniz olmasın. Yani bayt veri tipi kolayca görmezden gelebileceğiniz
gereksiz bir veri tipi değildir.</p>
</section>
<section id="bytes-fonksiyonu">
<h2>bytes() Fonksiyonu<a class="headerlink" href="#bytes-fonksiyonu" title="Link to this heading">¶</a></h2>
<p>Bayt veri tipi temel olarak ASCII karakterleri kabul eder. Dolayısıyla ASCII
tablosu dışında kalan karakterleri doğrudan bayt olarak temsil edemezsiniz:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s1">&#39;ş&#39;</span>

  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>
<span class="gr">SyntaxError</span>: <span class="n">bytes can only contain ASCII literal characters.</span>
</pre></div>
</div>
<p>Ama ASCII dışında kalan karakterleri de bayt’a dönüştürmenin bir yolu var. Bunun
için <code class="docutils literal notranslate"><span class="pre">bytes()</span></code> adlı bir fonksiyondan yararlanacağız:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="s2">&quot;ş&quot;</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Gördüğünüz gibi, ilgili karakterin hangi kod çözücü ile kodlanacağını
belirterek, bayt tipinde bir veri oluşturabiliyoruz.</p>
<p>Tahmin edebileceğiniz gibi, <code class="docutils literal notranslate"><span class="pre">bytes()</span></code> fonksiyonu, belirttiğimiz kod çözücü ile
kodlanamayan karakterlerle karşılaşılması durumunda ne yapılacağını
belirlememizi sağlayan <cite>errors</cite> adlı bir parametreye de sahiptir:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="s2">&quot;Fırat&quot;</span><span class="p">,</span> <span class="s2">&quot;ascii&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;xmlcharrefreplace&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>

<span class="go">b&#39;F&amp;#305;rat&#39;</span>
</pre></div>
</div>
<p>Önceki derslerimizde <cite>errors</cite> parametresinin hangi değerleri alabileceğini
tartışmıştık. Orada anlattığımız şeyler burada da geçerlidir.</p>
</section>
<section id="baytlarin-metotlari">
<h2>Baytların Metotları<a class="headerlink" href="#baytlarin-metotlari" title="Link to this heading">¶</a></h2>
<p>Bütün veri tiplerinde olduğu gibi, <cite>bytes</cite> adlı veri tipinin de birtakım
metotları bulunur. Bu metotların listesini almak için şu komutu
kullanabileceğinizi biliyorsunuz:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="nb">bytes</span><span class="p">)</span>
</pre></div>
</div>
<p>Listeye baktığınızda bu metotları karakter dizilerinin metotları ile hemen hemen
aynı olduğunu göreceksiniz. Baytların metotları arasında olup da karakter
dizilerinin metotları arasında olmayan metotları şu şekilde elde edebilirsiniz:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">bytes</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="go">decode</span>
<span class="go">fromhex</span>
</pre></div>
</div>
<p>Gördüğünüz gibi, <code class="docutils literal notranslate"><span class="pre">decode()</span></code> ve <code class="docutils literal notranslate"><span class="pre">fromhex()</span></code> adlı metotlar baytlarda var, ama
karakter dizilerinde yok. O yüzden biz de bu bölümde yalnızca bu iki metodu
incelemekle yetineceğiz. Çünkü öteki metotları zaten karakter dizilerinden
tanıyorsunuz.</p>
<section id="decode">
<h3>decode<a class="headerlink" href="#decode" title="Link to this heading">¶</a></h3>
<p>Hatırlarsanız karakter dizilerinin <code class="docutils literal notranslate"><span class="pre">encode()</span></code> adlı bir metodu vardı. Bu metot
yardımıyla karakter dizilerini belli bir kodlama biçimine göre kodlayabiliyor,
yani bunları baytlara çevirebiliyorduk. Mesela ‘İ’ harfini UTF-8 ile
kodlayalım:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;İ&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>

<span class="go">b&#39;\xc4\xb0&#39;</span>
</pre></div>
</div>
<p>Aynı harfi cp1254 ile kodlarsak şu çıktıyı elde ederiz:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;İ&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;cp1254&quot;</span><span class="p">)</span>

<span class="go">b&#39;\xdd&#39;</span>
</pre></div>
</div>
<p>Tahmin edebileceğiniz gibi, bu harfi ASCII ile kodlayamayız:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s2">&quot;İ&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">UnicodeEncodeError</span>: <span class="n">&#39;ascii&#39; codec can&#39;t encode character &#39;\u0130&#39; in position 0:</span>
<span class="x"> ordinal not in range(128)</span>
</pre></div>
</div>
<p>İşte bu kodlama işlemini tersine çevirebilmek, yani baytları belli bir kodlama
biçimine göre karakter dizilerine dönüştürebilmek için <code class="docutils literal notranslate"><span class="pre">decode()</span></code> metodundan
yararlanacağız:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\xc4\xb0</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>

<span class="go">&#39;İ&#39;</span>
</pre></div>
</div>
<p>Bu baytları bir de başka kodlama sistemleri ile kodlamayı deneyelim:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\xc4\xb0</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;cp1254&quot;</span><span class="p">)</span>

<span class="go">&#39;Ä°&#39;</span>
</pre></div>
</div>
<p>Gördüğünüz gibi, cp1254 adlı kod çözücü bu baytı çözebiliyor, ama yanlış
çözüyor! Çünkü bu baytın gösterdiği sayı cp1254 adlı kod sayfasında ‘İ’ye değil,
başka bir karaktere karşılık geliyor. Aslında başka iki karaktere, yani C4 ve B0
ile gösterilen <cite>Ä</cite> ve <cite>°</cite> karakterlerine karşılık geliyor… Bu durumu
<a class="reference external" href="https://en.wikipedia.org/wiki/Windows-1254">https://en.wikipedia.org/wiki/Windows-1254</a> adresine gidip kendiniz de
görebilirsiniz.</p>
<p>Bu baytları bir de ASCII ile çözmeye çalışalım:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\xc4\xb0</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>

<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">UnicodeDecodeError</span>: <span class="n">&#39;ascii&#39; codec can&#39;t decode byte 0xc4 in position 0: ordinal</span>
<span class="x">not in range(128)</span>
</pre></div>
</div>
<p>Elbette, bu karakter 128’den büyük bir sayıya karşılık geldiği için ASCII
tarafından çözülemeyecektir.</p>
</section>
<section id="fromhex">
<h3>fromhex<a class="headerlink" href="#fromhex" title="Link to this heading">¶</a></h3>
<p>Bu metot, onaltılı sayma sistemindeki bir sayıdan oluşan bir karakter dizisini
alıp, bayta dönüştürür. Bu metodu şöyle kullanıyoruz:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">bytes</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s2">&quot;c4b0&quot;</span><span class="p">)</span>

<span class="go">b&#39;\xc4\xb0&#39;</span>
</pre></div>
</div>
<p>Gördüğünüz gibi, bu metot bir onaltılı sayı olan <cite>c4b0</cite>’ı alıp, bize bir bayt
nesnesi veriyor.</p>
</section>
</section>
<section id="bayt-dizileri">
<h2>Bayt Dizileri<a class="headerlink" href="#bayt-dizileri" title="Link to this heading">¶</a></h2>
<p><cite>bytes</cite> adlı veri tipi ile elde ettiğimiz veri tıpkı karakter dizileri gibi,
üzerinde değişiklik yapılamayan bir veridir. Dolayısıyla bir <cite>bytes</cite> nesnesi
üzerinde değişiklik yapabilmek için o nesneyi tekrar tanımlamamız gerekir:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;PDF&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;-1.7&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">v</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>

<span class="go">b&#39;PDF-1.7&#39;</span>
</pre></div>
</div>
<p>Ama Python programlama dilinde <cite>bytes</cite> veri tipi dışında, baytlara ilişkin ikinci
veri tipi daha bulunur. <cite>bytearray</cite> adlı bu veri tipi, <cite>bytes</cite> veri tipinin
aksine, üzerinde değişiklik yapılabilen bir veri tipidir.</p>
<p>Python’da <cite>bytearray</cite> veri tipini şu şekilde tanımlıyoruz:</p>
<div class="highlight-py3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;PDF-1.7&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Gördüğünüz gibi, bir bayt dizisi tanımlayabilmek için <code class="docutils literal notranslate"><span class="pre">bytearray()</span></code> adlı bir
fonksiyondan faydalanıyoruz.</p>
</section>
<section id="bayt-dizilerinin-metotlari">
<h2>Bayt Dizilerinin Metotları<a class="headerlink" href="#bayt-dizilerinin-metotlari" title="Link to this heading">¶</a></h2>
<p>Bayt dizileri bir bakıma listelerle baytların karışımı gibidir. <code class="docutils literal notranslate"><span class="pre">dir(bytearray)</span></code>
gibi bir komutla bu veri tipinin metotlarını inceleyecek olursanız, bu veri
tipinin hem baytlardan hem de listelerden birtakım metotlar aldığını görürsünüz.</p>
<p>Bu veri tipi listelerin şu metotlarına sahiptir:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>append</p></li>
<li><p>clear</p></li>
<li><p>copy</p></li>
<li><p>count</p></li>
<li><p>extend</p></li>
<li><p>index</p></li>
<li><p>insert</p></li>
<li><p>pop</p></li>
<li><p>remove</p></li>
<li><p>reverse</p></li>
</ol>
</div></blockquote>
<p>Bu veri tipi baytların ise şu metotlarına sahiptir:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>capitalize</p></li>
<li><p>center</p></li>
<li><p>count</p></li>
<li><p>decode</p></li>
<li><p>endswith</p></li>
<li><p>expandtabs</p></li>
<li><p>find</p></li>
<li><p>fromhex</p></li>
<li><p>index</p></li>
<li><p>isalnum</p></li>
<li><p>isalpha</p></li>
<li><p>isdigit</p></li>
<li><p>islower</p></li>
<li><p>isspace</p></li>
<li><p>istitle</p></li>
<li><p>isupper</p></li>
<li><p>join</p></li>
<li><p>ljust</p></li>
<li><p>lower</p></li>
<li><p>lstrip</p></li>
<li><p>maketrans</p></li>
<li><p>partition</p></li>
<li><p>replace</p></li>
<li><p>rfind</p></li>
<li><p>rindex</p></li>
<li><p>rjust</p></li>
<li><p>rpartition</p></li>
<li><p>rsplit</p></li>
<li><p>rstrip</p></li>
<li><p>split</p></li>
<li><p>splitlines</p></li>
<li><p>startswith</p></li>
<li><p>strip</p></li>
<li><p>swapcase</p></li>
<li><p>title</p></li>
<li><p>translate</p></li>
<li><p>upper</p></li>
<li><p>zfill</p></li>
</ol>
</div></blockquote>
</section>
</section>



<div class='glyph'><a href='https://yazbel.com'>&#x2663;</a></div>
<div class='extrarelbar'> 
    <div class="related" role="navigation" aria-label="Related">
      <h3>Gezinti</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Genel Dizin"
             >dizin</a></li>
        <li class="right" >
          <a href="sozlukler.html" title="Sözlükler"
             >sonraki</a> |</li>
        <li class="right" >
          <a href="karakter_kodlama.html" title="Karakter Kodlama (Character Encoding)"
             >önceki</a> |</li>
<li class="nav-item nav-item-0"><a href=".">&#x2302;</a></li>

        <li class="nav-item nav-item-this"><a href="">Baytlar (Bytes) ve Bayt Dizileri (Bytearrays)</a></li> 
      </ul>
    </div> </div>

<div class='addcomment'>Yorumlar</div>

<div class='how-to-use'>
    <h3>Önemli Not</h3>
    Sorularınızı yorumlarda dile getirmek yerine <a href="https://forum.yazbel.com/">Yazbel Forumu</a>nda sorarsanız çok daha hızlı cevap alabilirsiniz.
    <br>
    Belgelerdeki bir hata veya eksiği dile getirecekseniz lütfen yorumları kullanmak yerine <a href="https://github.com/yazbel/python-istihza/issues">Github</a>'da bir konu (issue) açın.
    <br>
    Eğer yazdığınız yorum içinde kod kullanacaksanız kodlarınızı
    <span class='tag'>&lt;pre&gt;&lt;code&gt;</span> etiketleri içine alın. Örneğin:

    <pre>
        <span class='tag'>&lt;pre&gt;&lt;code class="python"&gt;</span>
        <span class='keyword'>print</span>(<span class='string'>"Merhaba Dünya!"</span>)
        <span class='tag'>&lt;/code&gt;&lt;/pre&gt;</span>
    </pre>
</div>


<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT
     *  THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR
     *  PLATFORM OR CMS.
     *
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT:
     *  https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        // Replace PAGE_URL with your page's canonical URL variable
        this.page.url = PAGE_URL;

        // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        this.page.identifier = PAGE_IDENTIFIER;
    };
    */

    (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
        var d = document, s = d.createElement('script');

        // IMPORTANT: Replace EXAMPLE with your forum shortname!
        s.src = 'https://istihza.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<noscript>
<br>
<a href="https://disqus.com/?ref_noscript" rel="nofollow">Disqus tarafından sağlanan yorumları</a> görmek için lütfen JavasScript'i etkinleştirin.
<br>
Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4eca48eb2d83faf9" async="async"></script>



            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div> 
    <div class="related" role="navigation" aria-label="Related">
      <h3>Gezinti</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Genel Dizin"
             >dizin</a></li>
        <li class="right" >
          <a href="sozlukler.html" title="Sözlükler"
             >sonraki</a> |</li>
        <li class="right" >
          <a href="karakter_kodlama.html" title="Karakter Kodlama (Character Encoding)"
             >önceki</a> |</li>
<li class="nav-item nav-item-0"><a href=".">&#x2302;</a></li>

        <li class="nav-item nav-item-this"><a href="">Baytlar (Bytes) ve Bayt Dizileri (Bytearrays)</a></li> 
      </ul>
    </div> 

<div class="footer">
		&copy; Copyright 2007-2024, Fırat Özgül | <a href="https://yazbel.com">yazbel.com</a>.
Son güncelleme: 19.08.2024.
	<a href="http://sphinx-doc.org/">Sphinx</a> 8.0.2 kullanılarak oluşturuldu.

	Yayım 4.1.3.
<br>
<br>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img
alt="Creative Commons License" style="border-width:0"
src="https://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a>
<br>
<br>
</div>
<!-- Start of StatCounter Code for Default Guide -->
<script type="text/javascript">
var sc_project=10396326;
var sc_invisible=1;
var sc_security="fb5cd679";
var scJsHost = (("https:" == document.location.protocol) ?
"https://secure." : "http://www.");
document.write("<sc"+"ript type='text/javascript' src='" +
scJsHost+
"statcounter.com/counter/counter.js'></"+"script>");
</script>
<noscript><div class="statcounter"><a title="hit counter"
href="http://statcounter.com/" target="_blank"><img
class="statcounter"
src="http://c.statcounter.com/10396326/0/fb5cd679/1/"
alt="hit counter"></a></div></noscript>
<!-- End of StatCounter Code for Default Guide -->

  </body>
</html>